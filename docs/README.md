# 프로젝트 설정 및 기타 노트

2022-12-19

---

![workflow status](https://github.com/LEE-sh1673/springboot-webservice/actions/workflows/main.yml/badge.svg)

# 교재 기준에서 변경된 점들

- Spring Boot 버전을 `2.4.1`으로 변경.
- Gradle 5.X 버전에서 Gradle `6.7.1`으로 변경함.
- IntelliJ IDEA `2020.3` 버전 사용. (<-> 필자는 `2022.01` 버전을 사용)
- Junit 버전이 4에서 5로 변경됨.
- Gradle 버전이 5버전 이후로 여러 가지로 많이 바뀌어 이에 따라 교재의 문법 또한 수정할 사항이 많음. (자세한 내용은 참고 문서의 저자의 블로그 글을 참고)
- 교재에서 다룬 Travis CI는 2020년에 travis.org라는 도메인을 페쇄하고 travis.com을 이용해야 한다. 책의 저자가 travis.com 혹은 Github Action을 쓸 것을 추천하였기 때문에 Travis CI 대신 Github Action을 사용함.

> 4장 이후의 필기 내용은 README가 아닌 노션에 정리함.

## 현재 설정

- Java Oracle OpenJDK 1.8 (Java 11)
- Gradle 6.7.1
- Intellij IDEA 2022.01
- Junit5
- Spring Boot 2.4.1

# 정리

- [3장](#3장)
- [4장](#4장)

## 3장

### JPA 소개

#### 등장 배경

- 관계형 데이터베이스와 객체지향 프로그래밍 언어의 패러다임은 서로 다르기 때문에, 객체를 데이터베이스에 저장할 때 여러 문제가 발생한다.
- 이러한 문제를 '패러다임 불일치'라고 하며, 이 때문에 상속, 1:N 등 다양한 객체 모델링을 데이터베이스로 구현할 수 없다. 그러다 보니 웹 애플리케이션 개발은 점점 데이터베이스 모델링에만 집중하게 된다. 
- 이런 문제점을 해결하기 위해 등장한 것이 JPA이다.

#### JPA

- JPA는 위와 같이 서로 다른 두 영역의 중간에서 패러다임을 일치 시켜주기 위한 자바 표준 ORM 기술이다.
- 개발자가 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행해준다. 

> **ORM (Object-relational mapping)**
> 
> 객체 관계 매핑(Object-relational mapping; ORM)은 데이터베이스와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법이다. 객체 지향 언어에서 사용할 수 있는 "가상" 객체 데이터베이스를 구축하는 방법이다.

### Spring Data JPA

- JPA는 자바 표준명세서로, 자바 애플리케이션이 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스이다.
- 따라서 이를 사용하기 위해서는 구현체가 필요한데, 대표적으로 Hibernate, Eclipse Link 등이 있다.
- 스프링에서는 보통 이 구현체들을 직접 다루지는 않으며, 이런 구현체들을 좀 더 쉽게 사용하고자 추상화시킨 Spring Data JPA를 사용한다.
- 즉, Spring Data JPA란 JPA 관련 기술들을 좀 더 쉽게 사용하기 위해 JPA를 한 단계 추상화시킨 모듈로서, 스프링 진영에서는 이 기술을 권장하고 있다.

#### Spring Data JPA

그렇다면 굳이 JPA의 구현체가 존재하는데, 왜 굳이 한 단계를 더 추상화시킨 것일까? 그냥 JPA로 접근하거나 구현체를 사용하는 방식이면 되지 않을까? 왜 이 기술이 필요한 것일까?

Spring Data JPA가 등장한 이유는 크게 두 가지이다.

- **구현체 교체의 용이성:**
  - JPA 구현체를 쉽게 교체할 수 있다.
  - Spring Data JPA는 내부에서 구현체 매핑을 지원해주기 때문이다.
- **저장소 교체의 용이성:**
  - 관계형 데이터베이스 외에 다른 저장소로 쉽게 교체할 수 있다.
  - 자료나 애플리케이션의 성격에 따라 다른 종류의 데이터베이스가 필요하다면 다른 Spring Data의 하위 인터페이스 (e.g. Spring Data MongoDB, Spring Data Redis 등)으로 교체하면 된다.

> 더 자세한 내용은 아래 블로그 참고: 
> [JPA, Hibernate, 그리고 Spring Data JPA의 차이점](https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/)

### 출력 로그 설정 관련

`application.properties`에 아래와 같이 설정하면 디버깅을 위해 출력되는 쿼리 로그를 MySQL 버전으로 변경할 수 있다.

```
# 실행된 쿼리를 로그로 보여줌. (default: H2)
spring.jpa.show-sql=true

# 쿼리를 MySQL 버전으로 변경함.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect
spring.jpa.properties.hibernate.dialect.storage_engine=innodb
spring.datasource.hikari.jdbc-url=jdbc:h2:mem:testdb;MODE=MYSQL
spring.datasource.hikari.username=sa
```

### DAO (Data Access Object) / Repository 영역

- iBatis나 MyBatis 등에서는 **Dao**라 불리고, JPA 등에서는 **Repository**라 불리는 DB Layer에 접근자 영역를 말한다.
- Dao 자체로는 말그대로 DB에 접근하는 객체를 말한다.
- JPA에서는 이런 DAO(JPA에서는 Repository라는 용어를 사용)를 생성할 때 보통 인터페이스로 생성한다.

#### Repository, Entity 클래스

- JPA에서는 '~Repository' 형태의 **인터페이스**를 생성하며, 이때 이 인터페이스 자체는 데이터베이스를 대상으로 할수 있는 작업들을 정의한 것이며, 실제 DB의 테이블과 연동되는 클래스인 'Entity' 클래스를 별도로 만든다.
- JPA에서 Entity 클래스는 `@Entity`을 붙여 만들고, DB 데이터에 작업할 경우 실제 쿼리를 날리는 대신, Entity 클래스의 수정을 통해 작업한다.
- 이런 Entity 클래스에서는 **절대 Setter 메서드를 만들지 않으며**, 필드의 값 변경이 필요하면 명확히 목적과 의도를 나타낼 수 있는 메서드를 추가한다.
- 그래서 DB에 새로운 데이터를 JPA를 통해 삽입할 경우에는 보통 생성자를 통해 최종값을 채운 후 삽입하거나, 데이터를 삽입, 수정하는 경우 해당 이벤트에 맞는 public 메서드를 호출하는 것을 전제로 한다.
- 다른 방법으로는 생성자 대신에 `@Builder`를 통해 제공되는 빌더 클래스를 사용하기도 한다. 빌더를 사용하는 경우는 생성자와 달리 어느 필드에 어떤 값을 채워야 하는지 명확히 인지할 수 있다는 장점이 있다.

> 여기서 주의할 점은 Entity 클래스와 기본 Entity Repository 는 함께 위치해야 된다는 점이다. Entity 클래스는 기본 Repository 없이는 제대로 역할을 할 수가 없다.

### 영속성 컨텍스트 (Persistence Context)

> 영속성(Persistence)이란 데이터를 영구적으로 저장하는 것을 의미합니다.

- 데이터(엔티티)를 영구적으로 저장하는 환경. 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 수행한다.
- JPA는 **엔티티 매니저**(Entity Manager)라는 것을 사용하는데, 이 매니저가 활성화된 상태로(Spring Data JPA를 쓴다면 기본 옵션) 트랜잭션 안에서 데이터베이스에서 데이터를 가져오면 이 데이터는 영속성 컨텍스트가 유지된 상태이다.
- 즉, Spring Data JPA에서 트랜잭션 안에서 데이터베이스에서 데이터를 가져오면 해당 데이터를 영속성 컨텍스트에 저장하게 된다.
- 영속성 컨텍스트에 등록된 데이터를 프로그램 중에 수정을 하게 되면, 영속성 컨텍스트에 존재하는 데이터와 데이터베이스에 존재하는 데이터의 상태가 서로 달라지게 된다.
- 이때 `@Transactional`은 스프링 AOP 전략에 따라 해당 데이터를 다루는 코드의 실행이 마무리될 때 해당하는 테이블에 변경분을 반영하게 된다. 따라서 Update 쿼리를 날릴 필요가 없어진다.

#### 더티 체킹(Dirty checking)

> 참고: [더티 체킹 (Dirty Checking)이란?](https://jojoldu.tistory.com/415)

이런 개념을 **더티 체킹**(dirty checking)이라 하는데, 간단히 말해 **상태 변경 검사**를 의미하며, JPA는 트랜잭션이 끝나는 시점에 **변화가 있는** 모든 엔티티 객체를 데이터베이스에 자동으로 반영해준다.

- 이때 변화가 있다의 기준은 **최초 조회 상태**이다.
- JPA에서는 엔티티를 조회하면 해당 엔티티의 조회 상태 그대로 스냅샷을 만들어놓는다.
- 그리고 트랜잭션이 끝나는 시점에는 이 스냅샷과 비교해서 다른점이 있다면 Update Query를 데이터베이스로 전달하게 된다.
- 단, 이런 상태 변경 검사의 대상은 영속성 컨텍스트가 관리하는 엔티티에만적용 됩니다.

## 4장

### 템플릿 엔진

- 템플릿 엔진이란 지정된 템플릿 양식과 데이터가 합쳐저 HTML 문서를 출력하는 소프트웨어를 말한다.
- Jsp, Freemarker, React, Vue 등이 템플릿 파일의 예시이다.
- 단, Jsp나 Freemarker의 경우 서버 템플릿 엔진이라고 하고, 후자는 클라이언트 템플릿 엔진이라 부른다.
- 서버 템플릿 엔진의 경우 화면 생성은 서버에서 Java 코드로 문자열을 만든 뒤 이 문자열을 HTML로 변환하여 브라우저로 전달한다.
- 반면 클라이언트 템플릿 엔진의 경우 브라우저에서 화면을 생성한다. 이 경우 서버에서 Json 혹은 Xml 형식의 데이터만 전달하고 클라이언트에서 조립하게 된다.
- 이와 관련된 용어로는 서버 사이드 렌더링(Server-Side Rendering; SSR)과 클라이언트 사이드 렌더링(Client-Side Rendering; CSR)이라는 것이 있다.

### SSR과 CSR

#### 클라이언트 사이드 렌더링

- 클라이언트 측에서 렌더링을 담당하는 것을 말한다.
- 기본적인 SPA의 구조를 예로 들자면, 보통 서버에서 HTML 파일을 클라이언트에 보내주는데, 이때 HTML 파일 자체는 전부 비어있게 되고, 이 안에 `script` 태그가 명시되어 있어 애플리케이션에 필요한 js 파일을 서버로부터 전송받는다. 그래서 처음에 접속하면 (혹은 이런 구조의 애플리케이션의 초기 렌더링 과정에서 문제가 발생하면) 빈 화면만 보이게 되는 것이다.
- 이 상태에서 서버로부터 받은 js 파일에는 애플리케이션 구동에 필요한 각종 로직들이 담겨지게 된다.
- 이후 상황에 맞게 필요한 데이터가 있다면 전체 파일을 서버로부터 받는 대신 json이나 xml 데이터를 받아 이를 처리(e.g. 부분 렌더링 등)한다.
- 이 방식의 큰 문제점은 **사용자가 화면을 보기까지 시간이 걸릴 수 있다**는 점이다. (서버로부터 js 파일을 받게 되는데, 이때 js 파일(들)은 용량이 크기 때문에 딜레이가 발생할 수 있다.)
- 또 다른 문제점으로는 **좋지 않은 SEO**를 가진다는 것이다. SEO란 검색 엔진 최적화(Search Engine Optimization; SEO)를 의미한다.
- 구글, 네이버와 같은 검색 엔진들은 서버에 등록된 웹 사이트를 돌아다니면서 웹 사이트의 HTML 문서를 분석하게 된다. (예를 들어 HTML 문서의 내용과 제목 관련 정보를 분석하여 검색 기능 최적화에 사용하는 것이다.)
- 그러나 앞에서 말했듯이 CSR 방식에서 사용되는 애플리케이션의 HTML 문서의 내용은 기본적으로는 비어져 있기 때문에 검색 엔진들이 CSR 방식으로 만들어진 웹페이지를 분석하는데 어려움이 있다. 이렇게 SEO가 좋지 못한 애플리케이션은 외부에 노출될 확률이 그만큼 줄어들고, 비지니스 적으로 큰 손해를 볼 가능성이 있다.


> 최근 SSR 방식을 사용하는 React나 Vue 등의 프레임워크들은 서버 사이드 렌더링 또한 지원한다.

#### 서버 사이드 렌더링

- 서버에서 자체적으로 화면을 생성하여 클라이언트로 보내주는 방식이다.
- 즉, CSR 방식은 클라이언트 측에서 서버로부터 받은 빈 HTML 문서와 Json/XML 데이터를 조립해서 최종적으로 사용자에게 보여지는 화면을 생성하는 방식이라면, SSR 방식은 사용자에게 보여지는 화면 생성 자체를 서버에서 모두 끝마친 뒤에 클라이언트로 전송해주는 방식이다.
- 이렇게 함으로써 CSR 방식에 비해 페이지의 로딩이 빨라진다. 또한 최종 화면 자체를 서버에서 만든 뒤에 보내주기 때문에 조금 더 효율적인 SEO를 할 수 있다. 
- **그러나 SSR의 경우 CSR 방식에 비해 사용자 편의성이 떨어질 수 있다.** 이는 static-site에서 발생되는 화면 깜빡임 문제 때문인데, CSR 방식의 경우 보통 SPA라면 특정 상황에 맞는 데이터를 받아와 부분적으로 렌더링하기 때문에 화면의 깜빡임이 비교적 적은 반면, SSR 방식의 경우 static-site와 같이 필요한 데이터, 페이지 등으로 이동할 경우 해당 페이지 자체를 서버에서 받아오게 되므로 화면의 깜빡임 횟수가 비교적 더 많다.
- 또다른 단점으로 **서버에 과부화가 걸리기가 쉽다.** 특히, 사용자가 많은 사이트의 경우, 요청에 따라 서버에서 화면을 생성해야 하는데, 이렇게 되면 과부화가 걸리기 쉬워진다.
- 가장 치명적인 단점으로는 **사용자가 빠르게 웹사이트를 확인할 수는 있지만 반응이 없을 수 있다.** 이는 화면을 구성하는 파일들은 가져왔지만, 동적으로 데이터를 처리하는 js 파일 등을 아직 다운로드하지 못해 발생할 수 있다. 이렇게 되면 사용자는 웹페이지에 접속하여 눈에 보이는 버튼 등을 클릭하여도 반응이 없는 경우가 발생할 수 있다.

#### TTV(Time To View) vs. TTI(Time To Interact)

그렇다면 CSR 방식에서는 이 문제들이 발생하지 않을까?

- CSR 방식의 경우 먼저 사용자는 빈 화면을 보게 되고, 서버로부터 웹 사이트에 필요한 로직들이 담겨져 있는 js 파일들을 받은 후, 최종적으로 동적으로 HTML을 생성할 수 있는 애플리케이션 로직이 담긴 js 파일을 받아오게 된다.
- 그리고 이 순간부터 사용자에게 전체 웹 사이트가 보여지게 되고, 사용자가 사이트와 상호작용이 가능해지는 것이다. 즉 CSR은 사용자가 웹 사이트를 볼 수 있음(TTV)과 동시에 클릭을 하거나 상호작용이 가능해지게 된다.(TTI)
- 즉 CSR 방식의 경우 사용자에게 화면이 보여지는 시점과 상호작용하는 시점이 동일하여 위에서 언급한 문제가 발생하지 않는 것이다.
- SSR 방식의 경우 먼저 서버가 사용자에게 보여지는 화면 관련 파일들을 클라이언트로 보내게 되고, 이후 최종적으로 js 파일을 받아와야지만 사용자가 웹 사이트와 상호작용할 수 있다. 이때 js 파일을 받아오는 시점은 상황에 따라 다르기 때문에 사용자가 화면은 보여지지만 상호작용이 불가능한 상황이 발생하는 것이다.
- CSR 방식의 경우 TTV와 TTI가 동일하고, SSR 방식은 TTV와 TTI가 다르다.

#### 개선하는 방법

- CSR 방식을 사용하는 경우 웹페이지를 동적으로 생성하는 js 파일(들)을 어떻게 하면 효율적으로 분할하여, 첫 번째로 사용가자 화면을 보기 위해 필요한 필수적인 요소들을 보낼 수 있을 지 고민해보면 좋을 것이다.
- SSR 방식의 경우 화면이 보이는 시점과 상화작용이 가능한 시점 사이의 시간 단차를 줄이기 위해 어떠한 노력을 할 수 있을지 어떻게 하면 조금 더 매끄러운 UI/UX를 제공할 수 있을지 고민해보면 좋다.

#### SSG(Static Site Generation)

- 사실 요즘에는 CSR 방식만을 고집하거나, SSR 방식만을 고집하지는 않는다.
- 또 다른 방법 중 하나인 SSG 방식은 정적 사이트 생성(Static Site Generation)을 의미하며, React의 경우 CSR 방식에 특화된 기술이지만 Gatsby라는 라이브러리와 함께 사용하면 React로 만든 웹 애플리케이션을 정적으로 미리 생성을 해두어서 서버에 배포해둘 수 있다.
- 이렇게 만들어진 웹 사이트에서 추가적으로 데이터를 서버에서 받아오거나 동적으로 처리해야 하는 로직이 있다면 자바스크립트 파일을 함께 가지고 있을 수 있기 때문에 동적인 요소도 충분히 추가할 수 있다.
- 또 다른 방법으로 React와 함께 많이 사용되는 기술인 Next.js 또한 SSG 방식을 지원할 뿐만 아니라 CSR 방식과 SSR 방식을 잘 섞어서 목적에 맞게 사용할 수 있도록 지원해주고 있다.

### TIP. @Transactional(readOnly=true)

트랜잭션 어노테이션에 `readOnly` 옵션을 `true` 값으로 설정하면 트랜잭션 범위는 유지하되, 조회 기능만 남겨두어 조회 속도가 개선할 수 있기 때문에 등록, 수정, 삭제 기능이 전혀 없는 서비스 메소드에서 사용하는 것이 좋다.


> 출처: [서버사이드 렌더링 (개발자라면 상식으로 알고 있어야 하는 개념 정리 ⭐️)](https://www.youtube.com/watch?v=iZ9csAfU5Os)

## 참고 문서

- [(2020.12.16) 스프링 부트와 AWS로 혼자 구현하는 웹 서비스 최신 코드로 변경하기](https://jojoldu.tistory.com/539)
- [교재 실습 코드 Github](https://github.com/jojoldu/freelec-springboot2-webservice/tree/version/2020-12-11)
- [Gradle - Dependency management](https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_plugin_and_dependency_management)
- [Github Actions 실행 후 이메일 보내기](https://www.ravsam.in/blog/send-email-notification-when-github-action-fails/)
- [P.320 chepter 09 Travis -> Git Hub Action 자동배포](https://github.com/ItsWard/aws-web-service/issues/1)
- [Github Actions + CodeDeploy + Nginx 로 무중단 배포하기](https://wbluke.tistory.com/39)